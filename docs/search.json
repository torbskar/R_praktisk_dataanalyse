[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Veldig praktisk dataanalyse med R",
    "section": "",
    "text": "Forord"
  },
  {
    "objectID": "surveyData.html#intro-dataformater",
    "href": "surveyData.html#intro-dataformater",
    "title": "1  Håndtering av data med innebygd metadata",
    "section": "1.1 Intro: Dataformater",
    "text": "1.1 Intro: Dataformater\nDet kan være ulike problemstillinger knyttet til type data, dataformater, men også hvordan noen har valgt å lagre/distribuere data. Det kan være vanskelig å skille mellom disse og man kan noen ganger lure på om det er hos R begrensningene ligger. Det kan være flere av disse, men som hovedregel er problemet at data ofte ikke er distribuert i et universelt format. Permanent lagring og distribusjon av data er krevende, men ikke temaet her. Uansett: du vil ofte få data i et format som ikke er tilrettelagt verken i eller for R. Å gjøre om data fra et format til et annet kan være en avgjørende oppgave for å få gjort noe som helst.\nDette kan være krøkete og du har vikelig muligheten til å kløne det til skikkelig. For at du skal slippe det gir dette kapittelet en oppskrift for å håndtere slike data slik at du kan jobbe videre med dem i R på en hensiktsmessig måte.\nDet er også noen utfordringer i R for håndtering av factor-variable med lange (noen ganger veldig lange) ‘labler’. Det gis noen løsninger på det også som gjør kodingen håndterbar."
  },
  {
    "objectID": "surveyData.html#noen-dataformater-typisk-for-norske-surveydata",
    "href": "surveyData.html#noen-dataformater-typisk-for-norske-surveydata",
    "title": "1  Håndtering av data med innebygd metadata",
    "section": "1.2 Noen dataformater typisk for norske surveydata",
    "text": "1.2 Noen dataformater typisk for norske surveydata\nI Norge er Sikt (tidliger NSD) en stor leverandør av data til samfunnsvitenskapen. De leverer ofte data i proprietære formater som SAS, SPSS eller Stata. I tillegg vil de levere en flat fil som typisk er comma separated variables (csv). I de førstnevnte vil metadata være integrert, mens i csv er det bare kodene og metadata må slås opp i dokumentasjonen."
  },
  {
    "objectID": "surveyData.html#suveydata-med-innebygd-metadata",
    "href": "surveyData.html#suveydata-med-innebygd-metadata",
    "title": "1  Håndtering av data med innebygd metadata",
    "section": "1.3 Suveydata med innebygd metadata",
    "text": "1.3 Suveydata med innebygd metadata\nEn type data som er mye brukt i samfunnsvitenskapen er surveydata, altså: data innhentet ved hjelp av spørreskjema. Slike data inneholder gjerne en god del kategoriske data eller man svarer på en likert-skala (f.eks. skala fra 1 til 5), men også kontinuerlige variable og kan også være tekstsvar.\nSlike data er ofte kodet slik at bestemte verdier har en tekstlig betydning. F.eks. 1 = “gift” og 2 = “ugift”, eller 1 = “veldig fornøyd” og 5 = “veldig misfornøyd” osv.\nI R vil slike variable normalt håndteres som såkalte faktor-variable, men ofte vil surveydata inneholde relativt lange tekstverdier som gjør det tungvint. Men det finnes løsninger. For å gjøre en lang historie kort: Surveydata er best å håndtere med pakkene {labelled}. For videre analyser er det derimot vanligvis best å ha faktor-variable, så vi vil oftest konvertere dataene etterpå. Det høres tungvindt ut, men konverteringen er bare et par linjer kode.\nEt spesielt problem er at i Stata og SPSS vil mange datasett inneholde spesielle verdier som skal tolkes som manglende data, såkalt ‘missing’. Det kan altså være egne koder for om respondenten ikke fikk stilt spørsmålet, ikke ville svare, eller andre grunner. For en variabel for inntekt kan f.eks. verdien 999999 betyr at vedkommende ikke ville svare. Når vi regner et gjennomsnitt er det da viktig at akkurat disse verdiene ikke inngår i beregningen. (Å kode på denne måten kan si er en uting uansett software, så vi skal i hvert fall kvitte oss med disse).\nI R er det flere pakker og funksjoner som er spesielt egnet til å håndtere slike data og vi skal bruke følgende:\n\nlibrary(haven)       # For å lese inn data fra SPSS, Stata eller SAS\nlibrary(labelled)    # For å håndtere variable og verdier som inneholder 'labler'\n\nI tillegg skal vi bruke pakker for generell datahåndtering som er samlet i pakken {tidyverse}, deriblant en pakke {forcats} for håndtering av kategoriske variable.\n\nlibrary(tidyverse)   # Generelle funksjoner for datahåndtering\n\nI det følgende skal vi dekke disse temaene:\n\nHvordan lese inn data fra Stata-formatet\nHvordan få oversikt over datasettet\nHvordan omkode variable med ‘labler’\nHvordan håndtere verdier som er kodet som ‘missing’ i Stata-formatet (kalles user-defined-NA i R)\nHvordan gjøre om labelled-variable til faktor-variable\nHvordan gjør det ovenstående på veldig mange variable på en gang (altså: fremfor en og en, så du kan bruke tiden din på morsommere ting)"
  },
  {
    "objectID": "surveyData.html#lese-inn-data-i-stata-formatet-.dta",
    "href": "surveyData.html#lese-inn-data-i-stata-formatet-.dta",
    "title": "1  Håndtering av data med innebygd metadata",
    "section": "1.4 Lese inn data i Stata-formatet .dta",
    "text": "1.4 Lese inn data i Stata-formatet .dta\nI det følgende bruker jeg som eksempel dataene NorLag som man kan få tilgang til via NSD/Sikt her: https://norlag.nsd.no/. Disse dataene kan lastes ned i flere ulike typer formater slik data fra NSD/Sikt gjerne kan. Tilsvarende vil altså gjelde for andre datasett derfra. De ulike dataformatene er typisk tilpasset spesifikke software og det er en utfordring hvis man bruker et annet system enn det NSD har sett for seg.\nDe leverer også data i csv-format som ikke er uavhengig av software og kan leses inn av alle typer statistikksoftware. Generelt er csv-formatet å foretrekke når man skal dele data nettopp av denne grunn. Det er også et format som ikke er sårbar for endringer i softwaren over lengre tid slik at det må konverteres mellom formatversjoner. Særlig for surveydata er derimot csv-formatet ikke alltid så godt i praksis da det krever en godt opplegg for dokumentasjon og metadata som trengs i kodingen av data. NSD/Sikt har valgt en måte å dokumentere metadata på som ikke er lett håndterbart maskinelt av ikke-profesjonelle programmerere. Dette gjør csv-formatet lite egnet i dette tilfellet.\nDerimot kan man laste ned dataene i formatene til SPSS eller Stata. Vi vil her forholde oss kun til Stata-filer, men det vil være tilsvarende med SPSS og i praksis også SAS. Stata-formatet har en filhale som slutter på ‘.dta’. Fordelen med dette formatet er at metadata er innebygd i selve dataformatet. Altså, at en kategorisk variabel vil inneholde både en tallkode og en tekst med informasjon om hva tallet betyr. Dette er imidlertid en måte å håndtere data på som ikke er optimal for R.\nI det følgende skal vi dekke * Lese inn Stata-filer * Søke etter variable * Undersøke hvordan variable er kodet, se på ‘lablene’ * Gjøre omkodinger av variablene * Endre variable til faktor-variable * Omkode faktor-variable med veldig lange tekstverdier\n\n1.4.1 Innlesning med {haven}\nFormatene Stata, SPSS og SAS er proprietære og man trenger i utgangspunktet disse softwarene for å åpne datafilene (og betale dyr lisens). For å lese inn i R kan man bruke pakken {haven} som inneholder spesialiserte funksjoner for å lese inn disse formatene. Funskjonen read_stata() leser inn dataene på en måte som bevarer særegenhetene fra Stata-formatet.\n\nnorlag <- read_stata(\"data/norlag_panel2022.dta\")"
  },
  {
    "objectID": "surveyData.html#få-oversikt-over-dataene",
    "href": "surveyData.html#få-oversikt-over-dataene",
    "title": "1  Håndtering av data med innebygd metadata",
    "section": "1.5 Få oversikt over dataene",
    "text": "1.5 Få oversikt over dataene\nVi har nå et datasett i minnet og vi bør ta en titt på det. Nå er det mange hundre variable i datasettet, så det er lite hensiktsmessig å printe det til konsollen fordi det er rett og slett ikke plass. I tidligere kurs skal dere ha lært å bruke funksjonen glimpse(), men også her blir det mest rotete fordi det er så mange variable.\nEn enkel løsning er å bare se på noen få variable om gangen. Med klammeparentes kan vi angi hvilke radnummer og kolonnenummer vi ønsker se på med følgende syntax: datasett[rader, kolonner] der altså komma skiller mellom rader og kolonner. Følgende eksempel viser hvordan man kan bruke head() for å vise de første observasjonene i datasettet med bare de første 5 variablene (altså: kollonne nr 1-5).\n\nhead(norlag[, 1:5])\n\n# A tibble: 6 × 5\n  ref_nr round iointervjumnd                 iointervjuyr ioalder               \n   <dbl> <dbl> <dbl+lbl>                     <dbl+lbl>    <dbl+lbl>             \n1      5     1      5                          2002           68                \n2      5     2     11                          2007           72                \n3      5     3 999999 [Deltok ikke i runden] 999999       999999 [Deltok ikke i…\n4     10     1      5                          2002           44                \n5     10     2      5                          2007           49                \n6     10     3      5                          2017           59                \n\n\nLegg merke til at under hvert variabelnavn står det en liten tekst, f.eks.  eller <S3: haven_labelled>. Det kan også stå andre ting. dbl betyr at det er en kontinuerlig variabel, mens haven_labelled betyr at det er labler til alle eller noe verdier i variabelen.\nEn tilsvarende variant er å bruke glimpse() bare på et utvalg variable på tilsvarende måte. Her er et eksempel, men der vi ser på de 10 første variablene.\n\nglimpse(norlag[, 1:20])\n\nRows: 33,084\nColumns: 20\n$ ref_nr          <dbl> 5, 5, 5, 10, 10, 10, 12, 12, 12, 15, 15, 15, 18, 18, 1…\n$ round           <dbl> 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, …\n$ iointervjumnd   <dbl+lbl>      5,     11, 999999,      5,      5,      5,   …\n$ iointervjuyr    <dbl+lbl>   2002,   2007, 999999,   2002,   2007,   2017,   …\n$ ioalder         <dbl+lbl>     68,     72, 999999,     44,     49,     59,   …\n$ iolandb         <dbl+lbl>      1,      1,      1,      1,      1,      1,   …\n$ iolandb3        <dbl+lbl>     NA,     NA, 999999,      1,      1,      1,   …\n$ iosvar          <dbl+lbl>      1,      1, 999999,      1,      1,      1,   …\n$ iofodselsyr     <dbl> 1934, 1934, 1934, 1957, 1957, 1957, 1955, 1955, 1955, …\n$ iokjonn         <dbl+lbl> 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1,…\n$ iopafyll        <dbl+lbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0,…\n$ iodeltagelse    <dbl+lbl> 5, 5, 5, 1, 1, 1, 2, 2, 2, 5, 5, 5, 3, 3, 3, 4, 4,…\n$ ionorlag1kohort <dbl+lbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,…\n$ iododyr         <dbl+lbl> 9996, 9996, 9996, 9996, 9996, 9996, 9996, 9996, 99…\n$ ssIO_sivil      <dbl+lbl>  2,  2, NA,  4,  4,  4,  2, NA,  2,  4,  4, NA, NA…\n$ hh001c          <dbl+lbl>      1,      1, 999999,      1,      1,      1,   …\n$ hh002           <dbl> 2, 2, 999999, 3, 2, 2, 2, 999999, 2, 1, 1, 999999, 999…\n$ pa001c          <dbl+lbl>      1,      1, 999999,      0,      1,      1,   …\n$ pa002c          <dbl+lbl>     NA,      1, 999999,     NA,      2,      2,   …\n$ pa003           <dbl+lbl>     60,     66, 999999,    996,     57,     67,   …\n\n\nI denne output’en er den første kollonnen altså variabelnavnene, deretter er det en kollonne som viser hva slags type variabel det er, og deretter de første observasjonene på hver variabel slik at man får et inntrykk av hvordan det ser ut. glimpse() gir altså omtrent samme informasjon som head(), men er nok mer hensiktsmessig hvis mange variable.\nFor å se nærmere på en variabel går an å bruke funksjonen look_for(), som primært er en søke-funksjon, men det gir også informasjon om variabelen.\n\nlook_for(norlag, \"iokjonn\")\n\n pos variable label     col_type values    \n 10  iokjonn  IOs kjønn dbl+lbl  [1] Mann  \n                                 [2] Kvinne\n\n\nI output fremgår det at dette er den 10’ende variabelen, inneholder informasjonen “IOs kjønn”, er av typen numerisk med tilhørende labler, og verdiene er 1 = Mann og 2 = Kvinne.\nDet går også an å bare få ut variabel-label med funksjonen var_label() slik:\n\nvar_label(norlag$iokjonn)\n\n[1] \"IOs kjønn\"\n\n\nFor å se labels på verdiene bruk val_labels().\n\nval_labels(norlag$iokjonn)\n\n  Mann Kvinne \n     1      2 \n\n\n\n1.5.1 Alternativ: pakken {memisc} og codebook()\nMan vil klare seg greit med det vi har vist ovenfor. Men det finnes flere måter å gjøre det på. Pakken {memisc} inneholder en rekke funksjoner for å håndtere surveydata, som vi ikke skal gå nærmere inn på her. Men akkurat funksjonen codebook() gir litt mer informativt output enn look_for().\nFor å bruke denne må du installere pakken først. I eksempelet nedenfor er pakken ikke lastet med library(), men angitt pakken direkte med memisc:: først. Dette kan være nyttig hvis man ikke skal bruke noen andre funksjoner fra denne pakken.\n\nmemisc::codebook(norlag$iokjonn)\n\n================================================================================\n\n   norlag$iokjonn 'IOs kjønn'\n\n--------------------------------------------------------------------------------\n\n   Storage mode: double\n   Measurement: undefined\n\n   Values and labels       N Percent\n                                    \n   1 'Mann'            16197    49.0\n   2 'Kvinne'          16887    51.0\n\n\nPoenget her er altså bare å få en penere output og litt deskriptiv statistikk samtidig."
  },
  {
    "objectID": "surveyData.html#søke-i-datasettet-etter-variable",
    "href": "surveyData.html#søke-i-datasettet-etter-variable",
    "title": "1  Håndtering av data med innebygd metadata",
    "section": "1.6 Søke i datasettet etter variable",
    "text": "1.6 Søke i datasettet etter variable\nAlle datasett skal komme med en dokumentasjon som sier hva hver variabel inneholder og hvilke verdier som finnes i hver variable, og hva de betyr. Dette leveres gjerne som en separat fil, ganske ofte i pdf eller html format. NSD/Sikt leverer dokumentasjonen for Norlag i html-format. (Ideelt burde det vært i et enkelt maskinlesbart format egnet til å bruke til omkoding og labler for de som ønsker det, men de har valgt en annen løsning).\nDu kan søke i dokumentasjonen på samme måte som i andre filer, men det kan være litt knotete. Et godt alternativ er å søke direkte i datasettet. Funksjonen look_for() søker både i variabelnavn, verdier og labler. Her er et eksempel for hvordan finne variabler som inneholder ordet “yrkesinntekt”. Du kan også søke på kortere eller lengre tekststrenger. (Søker du f.eks. bare på “innt” eller “yrke” så får du opp langt flere variable, så du må kanskje prøve deg litt frem).\n\nlook_for(norlag, \"Yrkesinntekt\")\n\n pos variable       label                   col_type values                 \n 353 inwyrkinnt     Yrkesinntekter NorLAG ~ dbl+lbl  [-5000] Value <0 >-5000\n                                                     [5000] Value >0 <5000  \n                                                     [999999999] Mangler da~\n 371 inpartwyrkinnt Partner: yrkesinntekte~ dbl+lbl  [99999996] Filter: IO ~\n                                                     [99999999] Mangler data\n                                                     [999999999] Deltok ikk~\n\n\nDet er to variable som inneholder teksten “yrkesinntekt”. Den første variabelen har posisjon 353 i datasettet og har variabelnavnet inwyrkinnt. Den andre variabelen har posisjon 371 og har navnet inpartwyrkinnt. Vi fokuserer på den første.\nMerk at når labelen avsluttes med ~ (uttales “tilde”) indikerer det at teksten er avkortet i outputvinduet. Du får opp hele teksten ved å bruke val_label() slik:\n\nvar_label(norlag$inwyrkinnt)\n\n[1] \"Yrkesinntekter NorLAG longitudinell\""
  },
  {
    "objectID": "surveyData.html#omkode-variable-som-er-labelled",
    "href": "surveyData.html#omkode-variable-som-er-labelled",
    "title": "1  Håndtering av data med innebygd metadata",
    "section": "1.7 Omkode variable som er labelled",
    "text": "1.7 Omkode variable som er labelled\nNoen ganger vil vi omkode en variabel. Et eksempel er variabelen he104. Her er innholdet i den variabelen.\n\nmemisc::codebook(norlag$he104)\n\n================================================================================\n\n   norlag$he104 'Hvordan vil du beskrive din økonomiske situasjon nå'\n\n--------------------------------------------------------------------------------\n\n   Storage mode: double\n   Measurement: undefined\n\n   Values and labels                                           N Percent\n                                                                        \n        1 'Veldig romslig'                                  1425     4.3\n        2 'Romslig'                                         8039    24.3\n        3 'Må være forsiktig, men klarer meg'               5152    15.6\n        4 'Problemer med å få pengene til å strekke til'     551     1.7\n        5 'Svært vanskelig økonomisk situasjon'              164     0.5\n      999 'Mangler data'                                     403     1.2\n    99999 'Ikke svart post/web-skjema'                      5158    15.6\n   999999 'Deltok ikke i runden'                           12192    36.9\n\n\nLegg merke til at de tre nederste verdiene egentlig er varianter av å mangle data. Disse verdiene skal normalt ikke være med i en videre analyse, men er “missing”. Vi bør fortelle R at disse verdiene ikke skal tas med videre ved å omkode til NA.\nFølgende kode gjør en omkoding til NA. I eksempelet har jeg lagt inn linjeskift for mutate() for å tydeliggjøre de ulike delene.\n\nFørste linje lager en ny variabel he104b som skal inne en kopi av he104. Funksjonen replace() tar så utgangspunkt i variabelen he104, og de verdiene som ikke er angitt at skal byttes ut vil beholdes fra denne.\n\nAndre linje sier at hvis variabelen he104 er en av verdiene 999, 99999, eller 999999, så…\nsier tredje linje at da skal de få verdien NA i stedet.\n\n\nnorlag %>% \n  mutate(he104b = replace(he104, \n                         he104 %in% c(999, 99999, 999999), \n                         NA)) %>%  \n    select(he104b) %>% \n  memisc::codebook()\n\n================================================================================\n\n   he104b 'Hvordan vil du beskrive din økonomiske situasjon nå'\n\n--------------------------------------------------------------------------------\n\n   Storage mode: double\n   Measurement: undefined\n\n   Values and labels                                           N Valid Total\n                                                                            \n        1   'Veldig romslig'                                1425   9.3   4.3\n        2   'Romslig'                                       8039  52.4  24.3\n        3   'Må være forsiktig, men klarer meg'             5152  33.6  15.6\n        4   'Problemer med å få pengene til å strekke til'   551   3.6   1.7\n        5   'Svært vanskelig økonomisk situasjon'            164   1.1   0.5\n      999   'Mangler data'                                     0   0.0   0.0\n    99999   'Ikke svart post/web-skjema'                       0   0.0   0.0\n   999999   'Deltok ikke i runden'                             0   0.0   0.0\n       NA M                                                17753        53.7\n\n\nLegg merke til at output nå har de omtalte verdiene 0 observasjoner, men lablene finnes i variabelen likevel! Lablene eksisterer altså uavhengig av verdiene i variabelen, men det har kommet en linje til med verdien NA. Det er det det ble omkodet til. Nå trenger vi jo ikke de lablene vi omkodet, så de kan fjernes helt. Funksjoen drop_unused_value_labels() gjør akkurat det det høres ut som. Her er et eksempel:\n\nnorlag %>% \n  select(he104) %>% \n  mutate(he104 = replace(he104, \n                         he104 %in% c(999, 99999, 999999), \n                         NA)) %>%  \n  drop_unused_value_labels() %>% \n  memisc::codebook()\n\n================================================================================\n\n   he104 'Hvordan vil du beskrive din økonomiske situasjon nå'\n\n--------------------------------------------------------------------------------\n\n   Storage mode: double\n   Measurement: undefined\n\n   Values and labels                                       N Valid Total\n                                                                        \n    1   'Veldig romslig'                                1425   9.3   4.3\n    2   'Romslig'                                       8039  52.4  24.3\n    3   'Må være forsiktig, men klarer meg'             5152  33.6  15.6\n    4   'Problemer med å få pengene til å strekke til'   551   3.6   1.7\n    5   'Svært vanskelig økonomisk situasjon'            164   1.1   0.5\n   NA M                                                17753        53.7\n\n\n\n1.7.1 Alternativ: legg til user-specified-na\nEn alternativ fremgangsmåte er mer slik man ville gjort i annen software ved at man definerer disse verdiene som “missing”, dvs NA. Funksjonen set_na_values() definerer hvilke verdier som skal regnes som NA, men uten å endre lablene eller kode om på annen måte.\n\nnorlag %>% \n  select(he104) %>% \n  set_na_values(he104 = c(999, 99999, 999999) ) %>% \n  memisc::codebook()\n\n================================================================================\n\n   he104 'Hvordan vil du beskrive din økonomiske situasjon nå'\n\n--------------------------------------------------------------------------------\n\n   Storage mode: double\n   Measurement: undefined\n   Missing values: 999, 99999, 999999\n\n   Values and labels                                           N Valid Total\n                                                                            \n        1   'Veldig romslig'                                1425   9.3   4.3\n        2   'Romslig'                                       8039  52.4  24.3\n        3   'Må være forsiktig, men klarer meg'             5152  33.6  15.6\n        4   'Problemer med å få pengene til å strekke til'   551   3.6   1.7\n        5   'Svært vanskelig økonomisk situasjon'            164   1.1   0.5\n      999 M 'Mangler data'                                   403         1.2\n    99999 M 'Ikke svart post/web-skjema'                    5158        15.6\n   999999 M 'Deltok ikke i runden'                         12192        36.9\n\n\nI output står det nå en “M” mellom verdien og labelen, som angir at dette er “Missing”. I frekvenstabellen er det nå i prosentueringen skilt mellom Valid og Total, der missing altså ikke er regnet med blant gyldige verdier.\nMen det er ryddigst å fjerne disse missing-verdiene og sette de til NA. Funksjonen zap_na() gjør disse verdiene om til NA, altså omkoder alle missingverdiene til NA. Som i forrige variant vil da lablene fremdeles eksistere, men disse kan fjernes på samme måte med drop_unused_value_labels().\n\nnorlag %>% \n  select(he104) %>% \n  set_na_values(he104 = c(999, 99999, 999999) ) %>% \n  zap_missing() %>% \n  drop_unused_value_labels() %>% \n  memisc::codebook()\n\n================================================================================\n\n   he104 'Hvordan vil du beskrive din økonomiske situasjon nå'\n\n--------------------------------------------------------------------------------\n\n   Storage mode: double\n   Measurement: undefined\n\n   Values and labels                                       N Valid Total\n                                                                        \n    1   'Veldig romslig'                                1425   9.3   4.3\n    2   'Romslig'                                       8039  52.4  24.3\n    3   'Må være forsiktig, men klarer meg'             5152  33.6  15.6\n    4   'Problemer med å få pengene til å strekke til'   551   3.6   1.7\n    5   'Svært vanskelig økonomisk situasjon'            164   1.1   0.5\n   NA M                                                17753        53.7"
  },
  {
    "objectID": "surveyData.html#omkoding-av-andre-verdier",
    "href": "surveyData.html#omkoding-av-andre-verdier",
    "title": "1  Håndtering av data med innebygd metadata",
    "section": "1.8 Omkoding av andre verdier",
    "text": "1.8 Omkoding av andre verdier\nVi starter med å lagre de endringene som ble testet ut over, og lagrer disse i et nytt datasett som kalles norlag2 som vi bruker videre i eksemplene.\n\nnorlag2 <- norlag %>% \n  select(he104) %>% \n  mutate(he104 = replace(he104, \n                         he104 %in% c(999, 99999, 999999), \n                         NA)) %>%  \n  drop_unused_value_labels() \n\nLa oss si at vi det er mindre viktig om man har det romslig eller veldig romslig. Det er heller ikke så viktig å skille mellom de som ‘problemer’ og de som har det ‘svært vanskelig’. Da ønsker vi å slå sammen disse kategoriene.\nFor å omkode en variabel som har labler kan vi bruke recode(). Det gjør vi typisk innenfor en mutate-setning.\n\nFørste linje sier at det skal lages en ny variabel, som er en rekodet variant av he104\nAndre linje sier at alle med verdien 1 skal gjøres om til verdien 2\nTredje linje sier at alle med verdien 5 skal gjøres om til verdien 4\n\nLegg merke til at den opprinneligve verdien angis innenfor apostrof 1, mens den nye verdien ikke skal angis med apostrof.\n\nnorlag2 %>% \n  mutate(okonomi = recode(he104, \n                          `1` = 2 ,\n                          `5` = 4) ) %>% \n  select(okonomi) %>% \n  memisc::codebook()\n\n================================================================================\n\n   okonomi 'Hvordan vil du beskrive din økonomiske situasjon nå'\n\n--------------------------------------------------------------------------------\n\n   Storage mode: double\n   Measurement: undefined\n\n   Values and labels                                       N Valid Total\n                                                                        \n    1   'Veldig romslig'                                   0   0.0   0.0\n    2   'Romslig'                                       9464  61.7  28.6\n    3   'Må være forsiktig, men klarer meg'             5152  33.6  15.6\n    4   'Problemer med å få pengene til å strekke til'   715   4.7   2.2\n    5   'Svært vanskelig økonomisk situasjon'              0   0.0   0.0\n   NA M                                                17753        53.7\n\n\nLegg merke til at de opprinnelge lablene fremdeles er der, men to av kategoriene har nå null observasjoner. Det innebærer jo også at lablene er litt misvisende, for det er jo egentlig kombinasjoner.\nÅ omkode lablene kan også gjøres. Funksjonen add_value_labels() angir hvilken variabel lablene skal angis for, og så settes ny label og hvilken verdi det tilsvarer. Lablene for verdier som ikke er nevnt blir beholdt slik de er.\n\nnorlag2 %>% \n  mutate(he104 = recode(he104, \n                          `1` = 2 ,\n                          `5` = 4,\n                        .combine_value_labels = TRUE) ) %>% \n  select(he104) %>% \n  add_value_labels(he104 = c(\"Romslig/veldig romslig\" = 2, \n                             \"Problemer/store problemer\" = 4)) %>% \n  memisc::codebook()\n\n================================================================================\n\n   he104 'Hvordan vil du beskrive din økonomiske situasjon nå'\n\n--------------------------------------------------------------------------------\n\n   Storage mode: double\n   Measurement: undefined\n\n   Values and labels                            N Valid Total\n                                                             \n    2   'Romslig/veldig romslig'             9464  61.7  28.6\n    3   'Må være forsiktig, men klarer meg'  5152  33.6  15.6\n    4   'Problemer/store problemer'           715   4.7   2.2\n   NA M                                     17753        53.7"
  },
  {
    "objectID": "surveyData.html#konverter-variable-til-et-mer-ordinært-r-format",
    "href": "surveyData.html#konverter-variable-til-et-mer-ordinært-r-format",
    "title": "1  Håndtering av data med innebygd metadata",
    "section": "1.9 Konverter variable til et mer ordinært R-format",
    "text": "1.9 Konverter variable til et mer ordinært R-format\nVi starter med å lagre en kopi av datasettet med endrede labler.\n\nnorlag3 <- norlag2 %>% \n  mutate(he104 = recode(he104, \n                          `1` = 2 ,\n                          `5` = 4,\n                        .combine_value_labels = TRUE) ) %>% \n  add_value_labels(he104 = c(\"Romslig/veldig romslig\" = 2, \n                             \"Problemer/store problemer\" = 4))\n\nMen hva skjer når vi skal lage en fin tabell? Vi prøver med {gtsummary} og tbl_summary().\n\nlibrary(gtsummary)\nnorlag3 %>% \n  tbl_summary(include = he104)\n\n\n\n\n\n  \n  \n    \n      Characteristic\n      N = 33,0841\n    \n  \n  \n    Hvordan vil du beskrive din økonomiske situasjon nå\n\n        2\n9,464 (62%)\n        3\n5,152 (34%)\n        4\n715 (4.7%)\n        Unknown\n17,753\n  \n  \n  \n    \n      1 n (%)\n    \n  \n\n\n\n\nTabellen vises altså uten lablene! Noe av poenget med å ha labler var jo å at det skal syens… Siden mange funksjoner i R i utgangspunktet ikke er laget for labler er det rett og slett ikke støttet.\nMen vi kan gjøre om variabelen med as_factor(). Gjør om lablene til faktor-nivåer og så lage en tabell med den endrede variabelen. (OBS! funskjonen as.factor() gjør bare nesten det samme. as_factor() er laget bl.a. for å håndtere labler, mens as.factor() ikke gjør det).\n\nnorlag3 %>% \n  mutate(he104 = as_factor(he104)) %>% \n  gtsummary::tbl_summary(include = he104)\n\n\n\n\n\n  \n  \n    \n      Characteristic\n      N = 33,0841\n    \n  \n  \n    Hvordan vil du beskrive din økonomiske situasjon nå\n\n        Romslig/veldig romslig\n9,464 (62%)\n        Må være forsiktig, men klarer meg\n5,152 (34%)\n        Problemer/store problemer\n715 (4.7%)\n        Unknown\n17,753\n  \n  \n  \n    \n      1 n (%)"
  },
  {
    "objectID": "surveyData.html#hvordan-gjøre-alt-i-en-fei-alle-variable-samtidig",
    "href": "surveyData.html#hvordan-gjøre-alt-i-en-fei-alle-variable-samtidig",
    "title": "1  Håndtering av data med innebygd metadata",
    "section": "1.10 Hvordan gjøre alt i en fei: alle variable samtidig",
    "text": "1.10 Hvordan gjøre alt i en fei: alle variable samtidig\nFor NorLAG er det noen missingverdier som er definert på tvers av hele datasettet. Se dokumentasjon her: https://norlag.nsd.no/filterverdier Å gjøre de operasjonene vi gjorde over for hver enkelt av de over 400 variablene er utrolig arbeidskrevende og drit kjedelig. Så det gidder vi ikke. Men å omkode alle variable i et helt datasett krever litt mer avanserte operasjoner. Her bruker vi across() som angir at vi skal gjøre samme operasjon på de nærere angitte variablene. Vi kan enten gi en liste med variabelnavn, eller sette et krav om at variablene skal være av en viss type, starte med visse bokstaver eller tegn osv. I eksempelet nedenfor angir vi bare at variabelene skal være av typen ‘labelled’, noe de aller fleste er. Missing-verdiene i datasettet er jo felles for alle variable, så da kan vi bruke replace() og sette disse til NA. Her er et eksempel:\n\nnorlag4 <- norlag %>% \n  mutate(across( where(is.labelled) ,  ~replace(., \n                                        . %in% c(997, 998, 999, 99999, 999999), \n                                        NA))) %>%  \n  drop_unused_value_labels()                                           \n\nI mutate-setningen skjer følgende:\n\nacross() sier at vi skal gjøre det samme for flere variable, spesifisert med where(is.labelled).\nfor disse skal vi bruke replace(), angitt ved ~replace()\ninni parentesen angis . som hver av de variablene som er plukket ut i across(). Så for disse variablene skal det byttes ut verdier\nneste linje starter med ., som igjen henviser til de samme variablen, og hvis de har en av de opplistede verdiene\ni så fall får de ny verdi NA\n\nDermed er samtlige labelled-variable omkodet på denne måten i en fei.\nDa kan vi lage en tabell på nytt. Her får vi samme problem med at lablene ikke synes, men missing-verdiene er i hvetr fall ryddet opp i.\n\nnorlag4 %>% \n  gtsummary::tbl_summary(include = he104)\n\n\n\n\n\n  \n  \n    \n      Characteristic\n      N = 33,0841\n    \n  \n  \n    Hvordan vil du beskrive din økonomiske situasjon nå\n\n        1\n1,425 (9.3%)\n        2\n8,039 (52%)\n        3\n5,152 (34%)\n        4\n551 (3.6%)\n        5\n164 (1.1%)\n        Unknown\n17,753\n  \n  \n  \n    \n      1 n (%)\n    \n  \n\n\n\n\nVi kan selvfølgelig endre til factor som gjort over, men da får vi igjen et problem med å gjøre det en variabel om gangen. Igjen: det gidder vi ikke. I stedet bruker vi en enkel funksjon som fikser biffen for hele datasettet, nemlig unlabelled().\n\nnorlag4 %>% \n  unlabelled() %>% \n  gtsummary::tbl_summary(include = he104)\n\n\n\n\n\n  \n  \n    \n      Characteristic\n      N = 33,0841\n    \n  \n  \n    Hvordan vil du beskrive din økonomiske situasjon nå\n\n        Veldig romslig\n1,425 (9.3%)\n        Romslig\n8,039 (52%)\n        Må være forsiktig, men klarer meg\n5,152 (34%)\n        Problemer med å få pengene til å strekke til\n551 (3.6%)\n        Svært vanskelig økonomisk situasjon\n164 (1.1%)\n        Unknown\n17,753\n  \n  \n  \n    \n      1 n (%)\n    \n  \n\n\n\n\nOBS! Unlabelled endrer alle labelled-variablene. Det er ikke sikkert at vi vil det. Spesielt gjelder det at det kan være andre labler knyttet til variable som skal være kontinuerlige. Men: hvis man har gjort en god opprydning i datasetet i forkant, med de omkodinger som trengs (det må nok gjøres en for en variabel), så er dette ganske greit.\n\n1.10.1 Sett det hele sammen: fiks hele skiten i en fei\nHvert steg ovenfor blir ganske omstendelig, og det ser vanskeligere ut enn det er. Her er en kode som setter det hele sammen i ett steg.\n\nnorlag <- read_stata(\"data/norlag_panel2022.dta\") %>% \n    mutate(across( where(is.labelled) ,  ~replace(., \n                                        . %in% c(997, 998, 999, 99999, 999999), \n                                        NA))) %>%\n    # Her kan ymse omkodinger av labeelled data gjøres: \n    mutate(he104 = recode(he104, \n                          `1` = 2 ,\n                          `5` = 4,\n                        .combine_value_labels = TRUE) ) %>% \n      # Her kan endrer du lablene hvis det trengs for de samme variablene: \n  add_value_labels(he104 = c(\"Romslig/veldig romslig\" = 2, \n                             \"Problemer/store problemer\" = 4)) %>% \n  # For hele datasettet fjernes ikke-brukte labler \n  drop_unused_value_labels() %>% \n  # Så gjør alle variable om til mer ordinære R-format. Dvs. gjøres labler om til factor\n  unlabelled()\n\nSå kan du gjøre andre analyser etter dette. Hvis du trenger å gå tilbake for å omkode flere labelled-variable, så legges dette til i mutate-setningen over. Det er lurt å gjøre all den typen omkoding ett sted, slik at du får et datasett som er ferdig ryddet og klart til andre analyser."
  },
  {
    "objectID": "surveyData.html#omkoding-av-factor-variable",
    "href": "surveyData.html#omkoding-av-factor-variable",
    "title": "1  Håndtering av data med innebygd metadata",
    "section": "1.11 Omkoding av factor-variable",
    "text": "1.11 Omkoding av factor-variable\nNoen ganger har man et datasett som allerede er omgjort med factor-variable. Eller du har en eller annen grunn til å ikke gå tilbake til et tidligere steg for å omkode. Men du har factor-levels med skikkelig lang tekst kan det være noe drit å kode om. Kan man gjøre dette på en lurere måte? Minst mulig tårer? Ja, selvsagt.\nI NorLAG er variabelen wr117zz svar på et spørsmål om “Mulighet for å redusert arbeidstid (deltid)”. Når denne variabelen er gjort om til factor kan man se hvilke verdier variabelen har med bruke av funksjonen levels() slik:\n\nlevels(norlag$wr117zz)\n\n[1] \"Nei\"                                                               \n[2] \"Ja\"                                                                \n[3] \"filter: jobber deltid\"                                             \n[4] \"filter: selvstendig næringsdrivende (NorLAG3 inkl frilanser/annet)\"\n[5] \"filter: ikke i arbeid\"                                             \n\ntable(norlag$wr117zz)\n\n\n                                                               Nei \n                                                              1360 \n                                                                Ja \n                                                              4146 \n                                             filter: jobber deltid \n                                                              1964 \nfilter: selvstendig næringsdrivende (NorLAG3 inkl frilanser/annet) \n                                                              1171 \n                                             filter: ikke i arbeid \n                                                              6238 \n\n\nLa oss si at vi vil kode om slik at vi får en variabel som bare er om vedkommende har mulighet til å jobbe deltid eller ikke. De som allerede jobber deltid har jo åpenbart mulighet til det, så de skal kodes om til “Ja”. De andre kategoriene er egentlig grunner til at det mangler data, så de skal settes til NA. En mulighet er da å omkode som følger:\n\nnorlag_omkodet <- norlag %>%\n  mutate(redarbtid = replace(wr117zz, wr117zz == \"filter: jobber deltid\", \"Ja\"), \n         redarbtid = replace(redarbtid, redarbtid == \"filter: selvstendig næringsdrivende (NorLAG3 inkl frilanser/annet)\", NA), \n         redarbtid = replace(redarbtid, redarbtid == \"filter: ikke i arbeid\", NA), \n         redarbtid = replace(redarbtid, redarbtid == \"vil ikke svare\", NA),\n         redarbtid = replace(redarbtid, redarbtid == \"vet ikke\", NA),\n         redarbtid = replace(redarbtid, redarbtid == \"mangler data\", NA),\n         redarbtid = replace(redarbtid, redarbtid == \"Deltok ikke i runden\", NA)) %>% \n  droplevels()\n\nDette funker, men blir ganske mye tekst å skrive, og da kan man også lett gjøre skrivefeil. Husk at faktornivåene må angis helt nøyaktig slik de er skrevet! Merk at den siste funksjone, droplevels(), bare fjerner faktor-levels som ikke er i bruk.\nI output for faktor-levels angir klammeparentesen gir rekkefølgen på disse verdiene. Vi kan bruke denne informasjonen direkte i omkodingen for å unngå å skrive så veldig mye. Når man bruker levels() får man en liten vektor med verdier, og disse kan man altså henvise til med rekkefølgen. Her er et eksempel for bare å bytte ut de som jobber deltid til “Ja”:\n\nnorlag_omkodet <- norlag %>%\n  mutate(redarbtid = replace(wr117zz, wr117zz == levels(wr117zz)[3], \"Ja\")) %>% \n  droplevels()\n\nTrikset her er altså å bruke levels() og vise til hvilket nummer i rekkefølgen. Da unngår vi også faren for skrivefeil.\nVi vil også kode om alle de andre verdiene, nummer 4-9 til NA. Det kan vi gjøre på samme måte, men vi behøver ikke skrive en ny linje for hver verdi. Den logiske operatoren == kan man bruke når man skal sjekke om to verdier er like. Hvis vi skal se om en verdi er lik en av flere mulige kan vi bruke %in% og så en liste med verdier. levels() gir en liste med verdier, så da kan vi angi den direkte og alle verdiene 4 til 9 ved å skrive 4:9. Samlet blir det da slik:\n\nnorlag_omkodet <- norlag %>%\n  mutate(redarbtid = replace(wr117zz, wr117zz == levels(wr117zz)[3], \"Ja\"), \n         redarbtid = replace(redarbtid, redarbtid %in% levels(wr117zz)[4:9], NA)) %>% \n  droplevels()\n\nmemisc::codebook(norlag_omkodet$redarbtid)\n\n================================================================================\n\n   norlag_omkodet$redarbtid\n\n--------------------------------------------------------------------------------\n\n   Storage mode: integer\n   Factor with 2 levels\n\n   Levels and labels     N Valid Total\n                                      \n    1 'Nei'           1360  18.2   4.1\n    2 'Ja'            6110  81.8  18.5\n   NA                25614        77.4"
  }
]